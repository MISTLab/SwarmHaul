include "includes/vec2.bzz"
include "includes/RVO.bzz"
include "includes/debug.bzz"

# Constants
# Note make sure INTER_ROBOT_CAGING_DIS > INTER_WP_TOLERENCE > SAFETY_DISTANCE,

SAFETY_DISTANCE = 35
HARMON_A0 = 0.0
HARMON_K = 1.0/50.0
TARGET_CONE_ANGLE = 0.05
CORNER_CAGE_LEN = 0.13
NORMAL_CAGE_ANGLE = 0.17
CORNER_CAGE_LEN = 0.9
INTER_WP_TOLERENCE = 0.4
INTER_ROBOT_CAGING_DIS=0.45


# Global Vaiables 
# Step time variable 
time = 0 

allow_corner_pass = 0
stored_target_array ={}
# State switch beteeen caging and pushing+Rotating
flag =1
# Flag to determine if centroid computation has to be done, done after the robots reaching a WP. 
FLAG = 0
# position of the pushed object. 
Pushed_obj_pos = {}
# Records the pervious task size, to identify the avilability of new tasks. 
last_size = 0
# List of positions on the left and right side, used for edge following and reaching the assigned target.
left_branch = {.1={.x=0,.y=0}}
right_branch = {.1={.x=0,.y=0}}
# Target to reach, used for estimating the cone to stop caging. 
target = {.x = 4,.y = 4}
# list of positions beinging copied from either left or right branch with the last position. 
target_array = {.1={.x=0,.y=0}}
# Current waypoint that the robot is performing to edge following and reaching assigned target.(only used in Caging)
x= 2
# Flag to determine if the robot is performing a task, used to determine if the robot is performing something, includes, following edge, pushing, rotating. 
TASK = 0
# Direction to spawn the next task for caging: left, right, top, down.
DIR = 1
DIR_AXIS = 1
OLD_DIR = DIR
# Total number of robots used for looping and getting centroid coordinates.
total_bots = 25
# Local target assigned for the robots during pushing and rotation. 
POS_DES={.x=0,.y=0}
# Timer that makes the robot wait before going into next waypoint.
Wait_time_for_next_task = 0


function init() { 
  # Swarm containing all the robots, used to execute gardient algorithm. (Robots leave on joing cagers or pushers)
  s = swarm.create(1)
  s.join()
  # All the robots that have reached the caging goal will be in this swarm. (Robots leave on joing cagers or pushers)
  cagers=swarm.create(2)
  # Stigmergy to stop caging. Once two robots reach the calulated target cone.
  barrier_cage= stigmergy.create(5)
  # Indicates the local goals in caging, identifies if the robot has reached its target while pushing and rotating.
  task = stigmergy.create(3)
  # K from the interval in gradient algorithm.
  k = 5
  # bidding max time.
  bidding_time = 70
  # List of timers for all caging tasks. 
  bidding_timer={}
  # The first task to initiate caging.
  task.put(1,{.id=id,.pos={.x=0,.y=0},.dir = -1,.dir_axis=-1,.bid=100000,.branch = 0})
  # List of robots that have completed pushing or rotating.
  barrier_array = {.1=100000} 
  # Current Waypoint pursued by the robot while pushing and rotating. 
  TASK_NUM = 0
  # All the robots that are pushing the object (leaves it when the barrier is satisfied)
  pushers=swarm.create(4)
  # All the robots in rotating mode (leaves it when the barrier is satisfied.)
  rotaters= swarm.create(5)
  # Sharing the path thought this stig.  
  barrier = stigmergy.create(20)
  # Number of robots that have reached the target for pushing and rotating.
  barrier2 = stigmergy.create(10)
  # Unused, To check 
  # barrier3 = stigmergy.create(11)
  # After caging, to find the size of the robots. 
  swarm_size = 0
   # = stigmergy.create(21)
  # Calculating the centroid after pushing after every waypoint. 
  centroid = stigmergy.create(23)
  # Hardcoded path for pushing. 
  barrier.put(0,{.cnt=0,.x=0.0,.y=0.0,.yaw = 0.01})
  barrier.put(2,{.cnt=0,.x=-1,.y=0,.yaw = 0.01})
  barrier.put(4,{.cnt=0,.x=-2,.y=0.3,.yaw = 0.01})
  barrier.put(6,{.cnt=0,.x=-2,.y=0.6,.yaw = 0.01})
  barrier.put(8,{.cnt=0,.x=-3,.y=0.9,.yaw = 0.01})
  barrier.put(10,{.cnt=0,.x=-4,.y=1.2,.yaw = 0.01})
  barrier.put(12,{.cnt=0,.x=-4.5,.y=0.33,.yaw = 0.01})
  barrier.put(14,{.cnt=0,.x=-5,.y=0.33,.yaw = 0.01})
  barrier.put(16,{.cnt=0,.x=-6,.y=0.33.,.yaw = 0.01})
  barrier.put(18,{.cnt=0,.x=-7,.y=0.33,.yaw = 0.01})
  barrier.put(20,{.cnt=0,.x=-8,.y=0.33,.yaw = 0.01})
  barrier.put(22,{.cnt=0,.x=-10,.y=0.33,.yaw = 0.01})
  task.onconflict(function (k,local,remote) {	
  		if(remote.bid <=local.bid)
  	    {return remote}
  		else {return local}})

  barrier.onconflict(function (k,local,remote) { 
      if(remote.robot<=local.robot)
      {
        return remote
      }
      else 
      {
        return local
      }
        
    }
  )


  centroid.onconflict(function (k,local,remote) { 
    if((local.data) and (not remote.data))
    {
     return local
    }
    else if((not local.data) and (remote.data))
    {
     return remote
    } 
    
    }
  )



  barrier2.onconflict(function (k,local,remote) { 
      if(local.data.val<remote.data.val)
        {
          check_and_add_barrier(local.robot,barrier_array)
          check_and_add_barrier(remote.robot,barrier_array)
          return remote
        }
      
      else if(local.data.val>remote.data.val)
      {
        check_and_add_barrier(local.robot,barrier_array)
        check_and_add_barrier(remote.robot,barrier_array)
        return local
      }

      if(local.data.val==remote.data.val)
      {
        check_and_add_barrier(local.robot,barrier_array)
        check_and_add_barrier(remote.robot,barrier_array)
        return remote
      }                                          

    }
  )

}



function step(){
  time = time + 1 
  var obstacle_vector = obs_vec()
  debug.print("Pos (",pose.position.x,",",pose.position.y,") obstacle_vector cnt", obstacle_vector.cnt, " obs len ", obstacle_vector.len, " ang ", obstacle_vector.ang)
  swarm_size = Cagers_SwarmSize + Pushers_SwarmSize + Rotators_SwarmSize

  if(flag){
    if ((s.in()) and (barrier_cage.size()<2)){
      s.exec(gradient)
    }
    if(cagers.in()){  
      if(barrier_cage.size()==2){
        log("caging_done")
        cagers.leave()
        flag = 0
        pushers.join()
        # swarm_size.put(id,1)
        TASK_NUM = 2
        TASK = 1
        POS_DES = math.vec2.add({.x = barrier.get(TASK_NUM).x - barrier.get(TASK_NUM - 2).x,.y = barrier.get(TASK_NUM).y - barrier.get(TASK_NUM - 2).y},pose.position)
        #log(id,POS_DES.x,":",POS_DES.y)
        #log(id,pose.position.x,":",pose.position.y)
        n = find_nei_in_set()
        yaw = barrier.get(TASK_NUM).yaw
      }
    }

    if(s.in()){
      if(TASK){
        show_colored_trajectory()
        var move_vec = obtain_local_vec_to_target(POS_DES,pose.position,pose.orientation.yaw)
        vector_to_target = math.vec2.scale(math.vec2.norm(move_vec), 30)
        #cmd_vel = LCA(vector_to_target)
         var cmd_vel = avoid_nei_using_potential(move_vec)
         cmd_vel = math.vec2.scale(cmd_vel,100)
        goto(cmd_vel.x, cmd_vel.y)
        if(target_array[x]){
          if((math.vec2.dis(POS_DES,pose.position)<INTER_WP_TOLERENCE)){
            log(x,":",id,": x",POS_DES.x,": y",POS_DES.y)
            x=x+1
            if(target_array[x]){
              POS_DES = target_array[x]
            }
          }
        }
        if(not target_array[x]){
          debug.print(" Distance: ", (math.vec2.dis(POS_DES,pose.position)), " obs len ", obstacle_vector.len, " cnt ", obstacle_vector.cnt, "Pos (",pose.position.x,",",pose.position.y,") going to (",POS_DES.x,",",POS_DES.y,")")
          if((math.vec2.dis(POS_DES,pose.position) < 0.03) or (obstacle_vector.len > NORMAL_CAGE_ANGLE) or allow_corner_pass == 1){
            #check_for_barrier(pose.position)
            log("[",id,"]",":",POS_DES.x,":",POS_DES.y)
            log("[",id,"]","obs.len:",obstacle_vector.len,"obs.ang:",obstacle_vector.ang," cnt ", obstacle_vector.cnt)
            TASK = 0
            POS_DES={.x=0,.y=0}
            
            next_task_update(obstacle_vector)
            if(size(target_array) <= 2){
              stored_target_array = math.vec2.new(0,0)
            }
            else{
              stored_target_array = math.vec2.new(target_array[x-1].x,target_array[x-1].y)
            }
            stored_target_array.size=size(target_array)
            target_array = {}
            allow_corner_pass = 1
            x=2
            if (obstacle_vector.cnt > CORNER_CAGE_LEN){
              goto(0.0,0.0)
              log("[",id,"] Leaving s swarm and joining cagers")
              s.leave()
              task = nil
              cagers.join()
            }
          }   
        }
      }
    }
  }

  if(not flag){
    if(barrier2.get(TASK_NUM)){
      check_and_add_barrier(barrier2.getrid(TASK_NUM),barrier_array)
      if((size(barrier_array)-1)>= swarm_size*(1)){
        if(pushers.in()){
          set_wheels(0.0,0.0)
          TASK = 0
          pushers.leave()
          rotaters.join()  
          log("[",id,"] Put centroid val")
          centroid.put(id,{.x=pose.position.x,.y=pose.position.y})
          barrier_array = {.1=17}
          TASK_NUM = TASK_NUM + 1
        }
        else if(rotaters.in()){
          set_wheels(0.0,0.0)
          centroid.put(id,NIL)
          FLAG =0
          rotaters.leave()
          pushers.join()
          TASK = 1
          barrier_array = {.1=17}
          TASK_NUM = TASK_NUM + 1
          if(id == 0)
          {
            log((TASK_NUM-2)/2,":",Pushed_obj_pos.x,":",Pushed_obj_pos.y)
          }
          POS_DES = math.vec2.add({.x = barrier.get(TASK_NUM).x - Pushed_obj_pos.x,.y = barrier.get(TASK_NUM).y - Pushed_obj_pos.y},pose.position)
          Prev_push_obj_pos = {.x = barrier.get(TASK_NUM).x,.y = barrier.get(TASK_NUM).y}
          n = find_nei_in_set()
          yaw = barrier.get(TASK_NUM).yaw
          if(TASK_NUM == 22)
          {
            log("Over ....... ")
            pushers.leave()
          }
        }
      }
    }

    if(pushers.in()){
      if(TASK){
        show_colored_trajectory()
        vector_to_neighbour = {.x =0,.y=0}
        move_in_wc = {.x=0,.y=0}
        move_vec = obtain_local_vec_to_target(POS_DES,pose.position,pose.orientation.yaw) 
        #var move_in=obtain_local_vec_to_target(Pushed_obj_pos,pose.position,pose.orientation.yaw)
        move_in_wc = math.vec2.newp(obs_vec_1().len,obs_vec_1().ang)

        vector_to_target = math.vec2.scale(math.vec2.norm(move_vec), 5)
        if(math.vec2.dis(move_in_wc,{.x=0,.y=0})>0){
          num = math.vec2.dot(move_vec,move_in_wc)
          denom =  math.vec2.length(move_vec) * math.vec2.length(move_in_wc) 
          angle = math.acos(num/denom)
          if((angle > 2) or (angle < -2))
          {
            move_in = math.vec2.scale(math.vec2.norm(move_in_wc), 1)
            vector_to_target = math.vec2.scale(math.vec2.norm(move_vec), 3)
          }
          else{
            vector_to_target = math.vec2.scale(math.vec2.norm(move_vec), 3)
            move_in = math.vec2.scale(math.vec2.norm(move_in_wc), 2)
          }
        }
        vector_to_neighbour = find_neighbours()
        if(math.vec2.dis(vector_to_neighbour,{.x=0,.y=0})>0){
          vector_to_neighbour = math.vec2.scale(math.vec2.norm(vector_to_neighbour), 2)
        }
        vector_to_target = math.vec2.add(vector_to_neighbour,vector_to_target)
        if (math.vec2.dis(move_in,{.x=0,.y=0})>0){
          vector_to_target = math.vec2.add(vector_to_target,move_in)
        }
        vector_to_target = math.vec2.scale(math.vec2.norm(vector_to_target), 20)
        goto(vector_to_target.x, vector_to_target.y)
        if(math.vec2.dis(POS_DES,pose.position)<0.03)
        {
          TASK = 0
          set_wheels(0.0,0.0)
          if(barrier2.get(TASK_NUM)){
            log("push:",TASK_NUM,":",id,":",size(barrier_array))
            barrier2.put(TASK_NUM,{.cnt = barrier2.get(TASK_NUM).cnt ,.val = barrier2.get(TASK_NUM).val +1})
          }
          else{
            barrier2.put(TASK_NUM,{.cnt = 1 , .val = 1})
          }
        }
      }
    }	
     
    if(rotaters.in()){
      #set_wheels(0.0,0.0)
      log("[",id,"] size of swarms ", swarm_size," centroid ", centroid.size()," null ", count_null())
      if((centroid.size()>=swarm_size) and (not FLAG) and (count_null()>=swarm_size)){
        if(Wait_time_for_next_task == 0){
          Wait_time_for_next_task = time 
        }
        else if(time - Wait_time_for_next_task > 10){
          Wait_time_for_next_task = 0
          TASK =1
          FLAG = 1
          #log(pose.position.x,pose.position.y)
          init_vector = math.vec2.sub(pose.position,Pushed_obj_pos)
          init_distance = math.vec2.dis(pose.position,Pushed_obj_pos)
          centre = calc_centroid()
          if (id == 0){
            log(id,":","centre",centre.x,":",centre.y)
            log(id,":","real",Pushed_obj_pos.x,":",Pushed_obj_pos.y)
            log(id,":","difference",math.vec2.dis(centre,Pushed_obj_pos))
          }
        }
      }
      if(TASK){
        show_colored_trajectory()
        move_away = {.x =0,.y=0}
        move_per=obtain_perpendicular(Pushed_obj_pos,pose.position)
        move_in=obtain_local_vec_to_target(Pushed_obj_pos,pose.position,pose.orientation.yaw)
        move_per = math.vec2.scale(math.vec2.norm(move_per), 30)
        move_in = math.vec2.scale(math.vec2.norm(move_in), 25)
        move_away = find_neighbours()
        if (math.vec2.dis(move_away,{.x=0,.y=0})>0){
          move_away = math.vec2.scale(math.vec2.norm(move_away), +20)
        }
        vector_to_target = math.vec2.add(move_per,move_in) 
        vector_to_target = math.vec2.add(vector_to_target,move_away)
        vector_to_target = math.vec2.scale(math.vec2.norm(vector_to_target), 9)
        goto(vector_to_target.x,vector_to_target.y)
        present_vec = math.vec2.sub(pose.position,Pushed_obj_pos)
        present_dis = math.vec2.dis(pose.position,Pushed_obj_pos)
        num = math.vec2.dot(present_vec,init_vector)
        denom = present_dis * init_distance
        angle = math.acos(num/denom)
        if ((angle > (yaw - 0.02)) and (angle < (yaw + 0.02))){
          TASK = 0
          set_wheels(0.0,0.0)
          if (barrier2.get(TASK_NUM)){
            barrier2.put(TASK_NUM,{.cnt = barrier2.get(TASK_NUM).cnt,.val = barrier2.get(TASK_NUM).val+1})
          }
          else{
           barrier2.put(TASK_NUM,{.cnt = 1 , .val = 1})
          }
        }
      }
    }
  }  # End of not flag 
}


function obtain_perpendicular(coord1,coord2){
  m_target = {.x =0, .y = 0}
  m_pos = {.x = 0,.y=0}
  m_pos = math.vec2.new(coord2.x,coord2.y)
  m_object = math.vec2.new(coord1.x,coord1.y)
  m_target = math.vec2.sub(m_object,m_pos)
  m_target = math.vec2.rotate(m_target,1.57 - pose.orientation.yaw)
  return m_target
}



function find_neighbours(){

  Accum ={.x=0,.y=0, .error=0}
  neighbors.foreach(
    function(rid, data){
      var error = ((data.distance - (INTER_ROBOT_CAGING_DIS*100)+10)/data.distance)
      var angular_error = 0
      if(n[rid]) angular_error=(data.azimuth - n[rid].a)/3.14 
      
      Accum.error = Accum.error + math.abs(error)
      if((n[rid]) or (data.distance < (INTER_ROBOT_CAGING_DIS*100)+10))
      {
          var my_vec = math.vec2.newp(data.distance, data.azimuth)
          Accum.x= Accum.x + ( error * (my_vec.x - math.cos(angular_error)))
          Accum.y= Accum.y + ( error * (my_vec.y - math.sin(angular_error)))
      }
    }
  )
  return Accum

}

function find_nei_in_set()
{
  var neighbours = {}
  neighbors.foreach(
  function(rid, data) 
  {
    if (data.distance< (INTER_ROBOT_CAGING_DIS*100)+10)
      {
        neighbours[rid] = {.a = data.azimuth}
      }
  })
  return neighbours
}


function check_and_add_barrier(a,t){
  var siz = size(t)
  var i = 1
  while(i<=(siz))
  {
    if(t[i] == a)
      {return}
    if(i == siz)
      {t[siz+1] = a
  }
    i = i+1
  }
}


function next_task_update(obs){   
  var i = task.size()
  if(i==1){
    target_point = {.x=0,.y=0}
    target_point.x = 4                     #-10*pose.position.x
    target_point.y = 4                     #-10*pose.position.y
    log("target x:",target_point.x," y:",target_point.y )
    #target.put("target",{.x = target_point.x, .y = target_point.y})
    if(( obs.ang  > 0.85 and obs.ang < 2.55 ) or ( obs.ang  < -0.85 and obs.ang > -2.55 )){
      log("[",id,"]  X increment " )
      DIR_AXIS = 1
      next_branch_one = {.id=id,.pos={.x=pose.position.x+INTER_ROBOT_CAGING_DIS,.y=pose.position.y},.dir=1,.dir_axis=DIR_AXIS,.bid = 1000000,.branch = 1}
      next_branch_two = {.id=id,.pos={.x=pose.position.x-INTER_ROBOT_CAGING_DIS,.y=pose.position.y},.dir=-1,.dir_axis=DIR_AXIS,.bid = 1000000,.branch =-1}
      task.put(i+1,next_branch_one)
      task.put(i+2,next_branch_two)
    }
    else if((obs.ang  < 0.85 and obs.ang > -0.85 ) or (obs.ang  < 3.67 and obs.ang > 2.55) or (obs.ang  > -3.67 and obs.ang < -2.55)){
      log("[",id,"]  Y increment " )
      DIR_AXIS = -1
      next_branch_one = {.id=id,.pos={.x=pose.position.x,.y=pose.position.y+INTER_ROBOT_CAGING_DIS},.dir=1,.dir_axis=DIR_AXIS,.bid = 1000000,.branch = 1}
      next_branch_two = {.id=id,.pos={.x=pose.position.x,.y=pose.position.y-INTER_ROBOT_CAGING_DIS},.dir=-1,.dir_axis=DIR_AXIS,.bid = 1000000,.branch = -1}
      task.put(i+1,next_branch_one)
      task.put(i+2,next_branch_two)
    }
  }
  else{
    var previous_point_check = Check_for_robots_in_previous_dir()
    if((( obs.ang  > 0.85 and obs.ang < 2.55 ) or ( obs.ang  < -0.85 and obs.ang > -2.55 ) and (obs.cnt > CORNER_CAGE_LEN)) ){
      log("[",id,"]  X increment " )
      if(OLD_DIR != 0 and previous_point_check==1) DIR = OLD_DIR
      #log("neighbour's around : ", neighbour_check())
      DIR_AXIS = 1
      next_one = {.id=id,.pos={.x=pose.position.x+(DIR*INTER_ROBOT_CAGING_DIS),.y=pose.position.y},.dir=DIR,.dir_axis=DIR_AXIS,.bid = 1000000,.branch = BRANCH}
      if(not check_for_barrier(next_one.pos)){
        log("[",id,"] Adding task: ", i+1)
        task.put(i+1,next_one)
      }
    }
    else if(((obs.ang  < 0.85 and obs.ang > -0.85 ) or (obs.ang  < 3.67 and obs.ang > 2.55) or (obs.ang  > -3.67 and obs.ang < -2.55) and (obs.cnt > CORNER_CAGE_LEN))){ 
      log("[",id,"]  Y increment " )
      if(OLD_DIR != 0 and previous_point_check==1) DIR = OLD_DIR
      #log("neighbour's around : ", neighbour_check())
      DIR_AXIS = -1
      next_one = {.id=id,.pos={.x=pose.position.x,.y=pose.position.y+(DIR*INTER_ROBOT_CAGING_DIS)},.dir=DIR,.dir_axis=DIR_AXIS,.bid = 1000000,.branch = BRANCH}
      if (not check_for_barrier(next_one.pos)){
        log("[",id,"] Adding task: ", i+1)
        task.put(i+1,next_one)
      }
    }
    else if(obs.cnt < CORNER_CAGE_LEN){
      OLD_DIR = DIR
      if(DIR_AXIS==1){
        log("[",id,"] Corner Y increment " )
        #log("neighbour's around : ",neighbour_check())
        if(math.vec2.dis({.x=pose.position.x,.y=pose.position.y+0.1},{.x=0,.y=0})>math.vec2.dis({.x=pose.position.x,.y=pose.position.y-0.1},{.x=0,.y=0})){
          log("[",id,"] y --")
          DIR = -1
          TASK = 1
          POS_DES = {.x=0,.y=0}
        }
        else{
          log("[",id,"] y ++")
          DIR = +1
          TASK = 1
          POS_DES = {.x=0,.y=0}
        }
      }
      else if(DIR_AXIS==-1)
      {
        log("[",id,"] Corner  X increment " )
        #log("neighbour's around : ",neighbour_check())
        if(math.vec2.dis({.x=pose.position.x+0.1,.y=pose.position.y},{.x=0,.y=0})>math.vec2.dis({.x=pose.position.x-0.1,.y=pose.position.y},{.x=0,.y=0}))
        {
          log("[",id,"] x --")

          DIR = -1
          TASK = 1
          POS_DES = {.x=0,.y=0}
        }
        else 
        {
          log("[",id,"] x ++")
          DIR = 1
          TASK = 1
          POS_DES = {.x=0,.y=0}
        }
      }
      # next_one = {.id=id,.pos={.x=0.0,.y=0.0},.dir=DIR,.dir_axis=DIR_AXIS,.bid = NIL,.branch = BRANCH}
      # if (not check_for_barrier(next_one.pos)){
      #   log("[",id,"] Adding task: ", i+1)
      #   task.put(i+1,next_one)
      # }
    } 
  }
}

function check_for_barrier(coord1)
{
  vec_next_one = math.vec2.new(coord1.x,coord1.y)
  vec_obs = math.vec2.new(0.0,0.0)
  #target_point = target.get("target")
  denom = math.vec2.dis(vec_obs,target)*math.vec2.dis(vec_next_one,target)
  obs_target = math.vec2.dis(vec_obs,target)
  next_one_target = math.vec2.dis(vec_next_one,target)
  vec_next_one=math.vec2.sub(vec_next_one,target)
  vec_obs = math.vec2.sub(vec_obs,target)
  num =  math.vec2.dot(vec_obs,vec_next_one)
  angle = math.acos((num/denom))
  if (((angle<TARGET_CONE_ANGLE) and (angle>-TARGET_CONE_ANGLE)) and (obs_target>next_one_target))
  {
    barrier_cage.put(id,1)
    log("barrier")
    return 1
  }
  else 
  {
    return 0
  }
}


function obtain_local_vec_to_target(coord1,coord2,yaw)
{
    m_target = {.x =0, .y = 0}
    m_pos = {.x = 0,.y=0}
    m_target = math.vec2.new(coord1.x,coord1.y)
    m_pos = math.vec2.new(coord2.x,coord2.y)
    m_target = math.vec2.sub(m_target,m_pos)
    m_target = math.vec2.rotate(m_target,-yaw)
    return m_target
}

function obs_vec()
{
  var accum = {.cnt = 0, .x=0, .y=0 }
  accum.x = 0.0
  accum.y = 0.0
  var accum_max=0
  var i = 0
  while(i < size(proximity)) {
  if(proximity[i].value > accum_max){
	  accum_max = proximity[i].value
  }
  accum.x = accum.x + proximity[i].value * math.cos(proximity[i].angle)
  accum.y = accum.y + proximity[i].value * math.sin(proximity[i].angle)
  i = i + 1
  }
  accum.x = accum.x / size(proximity)
  accum.y = accum.y / size(proximity)
  var len = math.sqrt(accum.x * accum.x + accum.y * accum.y)
  var ang = math.atan(accum.y, accum.x)
  accum = math.vec2.rotate(accum,+pose.orientation.yaw)
  len = math.sqrt(accum.x * accum.x + accum.y * accum.y)
  ang = math.atan(accum.y, accum.x)
  return {.len=len,.ang=ang, .cnt = accum_max}
}


function obs_vec_1()
{
  var accum = {}
  accum.x = 0.0
  accum.y = 0.0
  var i = 0
  while(i < size(proximity)) {
  accum.x = accum.x + proximity[i].value * math.cos(proximity[i].angle)
  accum.y = accum.y + proximity[i].value * math.sin(proximity[i].angle)
  i = i + 1
  }
  accum.x = accum.x / size(proximity)
  accum.y = accum.y / size(proximity)
  var len = math.sqrt(accum.x * accum.x + accum.y * accum.y)
  var ang = math.atan(accum.y, accum.x)
  len = math.sqrt(accum.x * accum.x + accum.y * accum.y)
  ang = math.atan(accum.y, accum.x)
  return {.len=len,.ang=ang}
}


function gradient()
{
  task_size = task.size()
  if(task_size - last_size)
  {

    i = 1
    while((i-1)<(task_size - last_size)) 
    {
      bidding_timer[last_size+i] = 0
      i = i + 1
    }
  }
  cnt = 1
  while(cnt-1 < task_size){ 
    if(task.get(cnt).bid){
      if(task.get(cnt).branch == 1){
        check_and_add(task.get(cnt).pos,left_branch)
      } 
      if(task.get(cnt).branch == -1){
        check_and_add(task.get(cnt).pos,right_branch)
      } 
      if ((not bidding_timer[cnt]%k) and (not TASK)){
        current_pose = math.vec2.new(pose.position.x,pose.position.y)
        current_bid = task.get(cnt).bid
        dir = task.get(cnt).dir
        my_bid = math.vec2.dis(task.get(cnt).pos,current_pose)
        dir_axis = task.get(cnt).dir_axis
        branch = task.get(cnt).branch
        if (current_bid>my_bid){
          task.put(cnt,{.id=id,.pos=task.get(cnt).pos,.dir = task.get(cnt).dir,.dir_axis=dir_axis,.bid=my_bid,.branch=branch})
        }
        bidding_timer[cnt] = bidding_timer[cnt] + 1
      }
      else{
        bidding_timer[cnt] = bidding_timer[cnt] + 1
      }
      
      if(bidding_timer[cnt] == bidding_time){
        if(task.get(cnt).id == id){
          if(not TASK){
            TASK = 1
            POS_DES = task.get(cnt).pos
            DIR = task.get(cnt).dir
            DIR_AXIS = task.get(cnt).dir_axis
            OLD_DIR =0
            BRANCH = task.get(cnt).branch
            if(BRANCH == 1){
              check_and_copy(POS_DES,left_branch)
            }
            if(BRANCH == -1){
              check_and_copy(POS_DES,right_branch)
            }
            print_array(target_array)

            if(target_array[2]){
              POS_DES = {.x = target_array[2].x,.y = target_array[2].y}
            }
               #if(size(target_array) < 7)
                    #{
                      #if(target_array[2])
                         #{
                          # POS_DES = {.x=target_array[2].x,.y=target_array[2].y}
                         #}
                    #}
               #else 
                    #{
                       #x = size(target_array) - 5
                       #POS_DES = {.x=target_array[x].x,.y=target_array[x].y}
                    #}
            task.put(cnt,{.id=id,.pos=task.get(cnt).pos,.dir = task.get(cnt).dir,.dir_axis=task.get(cnt).dir_axis,.bid=NIL,.branch=task.get(cnt).branch})
          }
          else{
            task.put(cnt,{.id=id,.pos=task.get(cnt).pos,.dir = task.get(cnt).dir,.dir_axis=task.get(cnt).dir_axis,.bid=NIL,.branch=task.get(cnt).branch})
            task.put(task.size()+1,{.id=id,.pos=task.get(cnt).pos,.dir = task.get(cnt).dir,.dir_axis=task.get(cnt).dir_axis,.bid=100000,.branch=task.get(cnt).branch})
          }
        }
      }
    }
    cnt = cnt + 1
  }  
  last_size = task_size

}

function check_and_add(a,t) {

  var siz = size(t)
  var i = 1
  while(i<=(siz))
  {
  if(((t[i].x == a.x) and (t[i].y == a.y)) or ((a.x == 0.0) and (a.y==0)))
      {return}
    
    if(i == siz)
      {
      t[siz+1] = a
      }
    i = i+1
  }
  
}


function check_and_copy(a,t) {
var siz = size(t)
var i=1
while(i<=(siz))
{
target_array[i] = t[i]
if((t[i].x == POS_DES.x) and (t[i].y == POS_DES.y))
{return} 
i = i+1
}

}


function print_array(t){
  if(t)
  {
  siz = size(t)
  var i = 1
  while(i<=siz)
    {
      log("id",id,":","i",i,":",t[i].x,":",t[i].y)
      i = i+1
    }
  }
}

function calc_centroid()
{
centre = {.x=0,.y=0}
siz = total_bots
var i = 0
while(i<siz)
  { 
    if(centroid.get(i))
    {
    centre.x = centroid.get(i).x/swarm_size + centre.x
    centre.y = centroid.get(i).y/swarm_size + centre.y
    }
    i = i + 1
  }
  
  return centre
}

function count_null()
{
siz = total_bots
var i = 0
var count = 0
while(i<siz)
{
  if(centroid.get(i))
  {
   count = count + 1
  }
  i=i+1
}
  if (id == 0)
  {
   log(id,"not null ",count)
  }
  return count 
}


function avoid_nei_using_potential(m_target){
  var Accum = {.cnt=0,.x=0.0,.y=0.0}
  neighbors.foreach(
    function(rid, data){
      var potential = harmonMagnitude(data.distance, SAFETY_DISTANCE, HARMON_A0, HARMON_K)
      if(data.distance < SAFETY_DISTANCE and potential < 0){
        var my_vec = math.vec2.newp(data.distance, data.azimuth)
        debug.rays.add(0,100,0, my_vec.x/100, my_vec.y/100, 0.0)
        var pot_vec = math.vec2.newp(potential, data.azimuth)
        Accum.x = Accum.x + pot_vec.x
        Accum.y = Accum.y + pot_vec.y
        Accum.cnt= Accum.cnt +1
      }
    }
  )
  if(Accum.cnt > 0){
    Accum.x = Accum.x/Accum.cnt
    Accum.y = Accum.y/Accum.cnt
  }
  var normalized_target_vec = math.vec2.new(m_target.x,m_target.y)
  normalized_target_vec = math.vec2.scale(normalized_target_vec, 1/math.vec2.length(normalized_target_vec))
  
  if(math.vec2.length(Accum) > 0) Accum = math.vec2.scale(Accum, 1/math.vec2.length(Accum))
  var target_weight = 0.6
  var return_vec = math.vec2.new((target_weight*normalized_target_vec.x)+ ((1-target_weight)*Accum.x),(target_weight*normalized_target_vec.y)+((1-target_weight)*Accum.y))
  # return_vec = math.vec2.scale(return_vec,10)
  return return_vec
}

function harmonMagnitude(dist, desiredDist, a0, k) {
  return a0 + ((dist - desiredDist)/math.abs(dist - desiredDist)) * 1.0/2.0 * k * (dist - desiredDist)^2
}

function Check_for_robots_in_previous_dir(){
  var previous_point = math.vec2.new(stored_target_array.x,stored_target_array.y)
  if(stored_target_array.size <= 2){
    if(DIR_AXIS == -1){
      previous_point = {.x=pose.position.x,.y=pose.position.y-(DIR*INTER_ROBOT_CAGING_DIS)}
    }
    else{
      previous_point = {.x=pose.position.x-(DIR*INTER_ROBOT_CAGING_DIS),.y=pose.position.y}
    }
    # previous_point = math.vec2.new(target_array[index_of_array].x,target_array[index_of_array].y)
  }
  
  log("[",id,"] last point ", previous_point.x,",",previous_point.y)
  previous_point =math.vec2.sub(previous_point,pose.position)
  previous_point = math.vec2.rotate(previous_point, -pose.orientation.yaw)
  var previous_point_ang = math.vec2.angle(previous_point)
  var comparision_result = {.res=0}
  neighbors.foreach(function(rid, data){
    # var my_vec = math.vec2.newp(data.distance, data.azimuth)
    var ang_diff = math.abs(previous_point_ang - data.azimuth)
    if(ang_diff < 0.08 and data.distance < INTER_ROBOT_CAGING_DIS*200){
    log("[",id,"] ang diff with ",rid, " is ", ang_diff)

      comparision_result.res = 1
    }
  })
  return comparision_result.res  
}
