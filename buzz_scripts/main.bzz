include "includes/vec2.bzz"
include "includes/RVO.bzz"
include "includes/debug.bzz"


Pushed_obj_pos = {}
target = {.x=2.0,.y=2.0}
last_size = 0
function init() { 
TASK = 0
DIR = 1
POS_DES={.x=0,.y=0}
s = swarm.create(1)
s.join()
cagers=swarm.create(2)
pushers=swarm.create(4)
barrier= stigmergy.create(5)
task = stigmergy.create(3)
task.put(1,{.id=id,.pos={.x = 0,.y=0},.dir = -1,.bid=100000})
k = 10
bidding_time = 50
bidding_timer={}
task.onconflict(function (k,local,remote) {	
		if(remote.bid <=local.bid)
	    {return remote}
		else {return local}})
}
  

function step()
{
    
    #log(id,": size ",task.size(),TASK," : pos",POS_DES.x,":",POS_DES.y)
    s.exec(gradient)
    if(cagers.in()) {  
    if (barrier.size()==2)
    {
      cagers.leave()
      pushers.join()
      TASK = 1
      POS_DES = math.vec2.add(target,pose.position)
    }
    
    }
    if(s.in()){
    if(TASK)
    {
    show_colored_trajectory()
    #log(id,": distance",math.vec2.dis(POS_DES,pose.position))
    var move_vec = obtain_local_vec_to_target(POS_DES,pose.position,pose.orientation.yaw)
    vector_to_target = math.vec2.scale(math.vec2.norm(move_vec), 100.0)
    cmd_vel = LCA(vector_to_target)
    goto(cmd_vel.x, cmd_vel.y)

    if((math.vec2.dis(POS_DES,pose.position)<0.01) or (obs_vec().len > 0.2))
    {
        TASK = 0
        prox_vec = obs_vec()
        next_task_update(prox_vec)
        POS_DES={.x=0,.y=0}
        set_wheels(0.0,0.0)
        if (prox_vec.len > 0.05)
        {
        s.leave()
        cagers.join()
        }
    }
    }
    }

    if(pushers.in()){
    if(TASK)
    {
    show_colored_trajectory()
    #log(id,": distance_to_target",math.vec2.dis(POS_DES,Pushed_obj_pos))
    var move_vec = obtain_local_vec_to_target(POS_DES,pose.position,pose.orientation.yaw)
    vector_to_target = math.vec2.scale(math.vec2.norm(move_vec), 100.0)
    #cmd_vel = LCA(vector_to_target)
    goto(vector_to_target.x, vector_to_target.y)
    if(math.vec2.dis(target,pose.position)<0.01)
    {
      TASK = 0
      pushers.leave()
      set_wheels(0.0,0.0)
      s.in() 
    }

    }}
    

}

function next_task_update(obs)
{   
  i = task.size()
  if (i==1)
  {
  if  (( obs.ang  > 1 and obs.ang < 2.2 ) or ( obs.ang  < -1 and obs.ang > -2.2 ))
  {
    #log(id,":y")
  next_branch_one = {.id=id,.pos={.x=pose.position.x+0.25,.y=pose.position.y},.dir=1,.bid = 1000000}
  next_branch_two = {.id=id,.pos={.x=pose.position.x-0.25,.y=pose.position.y},.dir=-1,.bid = 1000000}
  task.put(i+1,next_branch_one)
  task.put(i+2,next_branch_two)
  }
  else if  ((obs.ang  < 0.96 and obs.ang > -0.96 ) or (obs.ang  < 3.67 and obs.ang > 2.67) or (obs.ang  > -3.67 and obs.ang < -2.67))
  {
    #log(id,":x")
  next_branch_one = {.id=id,.pos={.x=pose.position.x,.y=pose.position.y+0.25},.dir=1,.bid = 1000000}
  next_branch_two = {.id=id,.pos={.x=pose.position.x,.y=pose.position.y-0.25},.dir=-1,.bid = 1000000}
  task.put(i+1,next_branch_one)
  task.put(i+2,next_branch_two)
  }
  
  }
  else 
  {
  if  (( obs.ang  > 1 and obs.ang < 2.2 ) or ( obs.ang  < -1 and obs.ang > -2.2 ) and (obs.len > 0.05))
  {
    #log(id,":y")
    
  next_one = {.id=id,.pos={.x=pose.position.x+(DIR*0.25),.y=pose.position.y},.dir=DIR,.bid = 1000000}
  if (not check_for_barrier(next_one.pos))
  {
  task.put(i+1,next_one)
  }
  }
  else if  ((obs.ang  < 0.96 and obs.ang > -0.96 ) or (obs.ang  < 3.67 and obs.ang > 2.67) or (obs.ang  > -3.67 and obs.ang < -2.67) and (obs.len > 0.05))
  { 
  next_one = {.id=id,.pos={.x=pose.position.x,.y=pose.position.y+(DIR*0.25)},.dir=DIR,.bid = 1000000}
  if (not check_for_barrier(next_one.pos))
  {
  task.put(i+1,next_one)
  }
  }
  else if (obs.len < 0.05)
  {
  #log("change axis")
  DIR = 1
  next_one = {.id=id,.pos={.x=0.0,.y=0.0},.dir=DIR,.bid = 1000000}
  task.put(i+1,next_one)
  }
  }
  

  }

function check_for_barrier(coord1)
{
  vec_next_one = math.vec2.new(coord1.x,coord1.y)
  vec_obs = math.vec2.new(0.0,0.0)
  denom = math.vec2.dis(vec_obs,target)*math.vec2.dis(vec_next_one,target)
  obs_target = math.vec2.dis(vec_obs,target)
  next_one_target = math.vec2.dis(vec_next_one,target)
  vec_next_one=math.vec2.sub(vec_next_one,target)
  vec_obs = math.vec2.sub(vec_obs,target)
  num =  math.vec2.dot(vec_obs,vec_next_one)
  log(id,":",num,":",denom)
  angle = math.acos((num/denom))
  if (((angle<0.08) and (angle>-0.08)) and (obs_target>next_one_target))
  {
    barrier.put(id,1)
    log(id,":",barrier.size())
    return 1
  }
  else 
  {
    return 0
  }
}



function obtain_local_vec_to_target(coord1,coord2,yaw)
{
    m_target = math.vec2.new(coord1.x,coord1.y)
    m_pos = math.vec2.new(coord2.x,coord2.y)
    m_target = math.vec2.sub(m_target,m_pos)
    m_target = math.vec2.rotate(m_target,-yaw)
    return m_target
}

function obs_vec()
{
  var accum = {}
  accum.x = 0.0
  accum.y = 0.0
  var i = 0
  while(i < size(proximity)) {
	accum.x = accum.x + proximity[i].value * math.cos(proximity[i].angle)
	accum.y = accum.y + proximity[i].value * math.sin(proximity[i].angle)
	i = i + 1
  }
  accum.x = accum.x / size(proximity)
  accum.y = accum.y / size(proximity)
  var len = math.sqrt(accum.x * accum.x + accum.y * accum.y)
  var ang = math.atan(accum.y, accum.x)
  #log (id," :",len," :",ang)
  accum = math.vec2.rotate(accum,+pose.orientation.yaw)
  len = math.sqrt(accum.x * accum.x + accum.y * accum.y)
  ang = math.atan(accum.y, accum.x)
  #log (id," :",len," :",ang)
  #log("-------------------")
  return {.len=len,.ang=ang}
}

function gradient()
{
    task_size = task.size()
    if(task_size - last_size)
    {
      i = 1
      while((i-1)<(task_size - last_size)) 
      {
        bidding_timer[last_size+i] = 0
        i = i + 1
      }
    }
    cnt = 1
    while(cnt-1 < task_size)
    { 
      if(task.get(cnt).bid)
      {
      if ((not bidding_timer[cnt]%k) and (not TASK))
      {
      current_pose = math.vec2.new(pose.position.x,pose.position.y)
      current_bid = task.get(cnt).bid
      dir = task.get(cnt).dir
      my_bid = math.vec2.dis(task.get(cnt).pos,current_pose)
      #log(id,": bid",current_bid," : my_bid",my_bid," :dir",dir)
      if (current_bid>my_bid)
         {
           task.put(cnt,{.id=id,.pos=task.get(cnt).pos,.dir = task.get(cnt).dir,.bid=my_bid})
         }
         bidding_timer[cnt] = bidding_timer[cnt] + 1
      }
      else 
         {
           bidding_timer[cnt] = bidding_timer[cnt] + 1
         }
      
      if (bidding_timer[cnt] == bidding_time)
      {
        if (task.get(cnt).id == id)
        {
          if(not TASK)
          {
          TASK = 1
          POS_DES = task.get(cnt).pos
          DIR = task.get(cnt).dir
          task.put(cnt,{.id=id,.pos=task.get(cnt).pos,.dir = task.get(cnt).dir, .bid=NIL})
          }
          else
          {
            task.put(cnt,{.id=id,.pos=task.get(cnt).pos,.dir = task.get(cnt).dir, .bid=NIL})
            task.put(task.size()+1,{.id=id,.pos=task.get(cnt).pos,.dir = task.get(cnt).dir, .bid=100000})
          }
        }
      }
      }
      cnt = cnt + 1
    }  
    last_size = task_size
}
