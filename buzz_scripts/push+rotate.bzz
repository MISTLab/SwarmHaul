include "includes/vec2.bzz"
include "includes/RVO.bzz"
#include "includes/debug.bzz"


Pushed_obj_pos = {}
#target = {{.x=2.5,.y=2.5,.yaw = 1.57},{.x=5.0,.y=5.0,.yaw = 1.57}}
GOAL_STATE = math.vec2.new(-22.5, 16.5)

START_STATE = math.vec2.new(0.0 , 0.0)

function init() {
SWARM_SIZE = 12 
TASK_NUM = 1
TASK = 1
pushers=swarm.create(4)
#pushers.join()
rotaters= swarm.create(5)
barrier = stigmergy.create(3)
barrier.put(1,{.x=1,.y=0,.yaw = 0.75})
barrier.put(2,{.x=0,.y=1,.yaw = 0.75})
barrier.put(3,{.x=1,.y=0,.yaw = 0.75})
barrier.put(4,{.x=0,.y=-1,.yaw = 0.75})
TIME_STEP = 1
POS_DES = {.x=0,.y=0}
barrier.onconflict(function (k,local,remote) { 
    if(remote.data <=local.data)
      {return local}
    else {return remote}})
}

function step(){

    if (TIME_STEP == 1)
    {
    if ()
    LoadGTMap()
    path_controls = OneShotPathPlanner(0.0,0.0,5.0,5.0,0.2)
    table_print_path(path_controls)
    POS_DES = math.vec2.add({.x = barrier.get(TASK_NUM).x,.y = barrier.get(TASK_NUM).y},pose.position)
    n = find_nei_in_set()
    yaw = barrier.get(TASK_NUM).yaw
    barrier.put(TASK_NUM,1)
    }

    if (barrier.get(TASK_NUM)>= 9)
    {
      if(pushers.in())
      {
      pushers.leave()
      rotaters.join()
      TASK = 1
      init_vector = math.vec2.sub(pose.position,Pushed_obj_pos)
      init_distance = math.vec2.dis(pose.position,Pushed_obj_pos)
      barrier.put(TASK_NUM,1)
      }

      else if(rotaters.in())
      {
      barrier.put(TASK_NUM,nil)
      rotaters.leave()
      pushers.join()
      TASK = 1
      TASK_NUM = TASK_NUM + 1
      log(TASK_NUM)
      POS_DES = math.vec2.add({.x = barrier.get(TASK_NUM).x,.y = barrier.get(TASK_NUM).y},pose.position)
      n = find_nei_in_set()
      yaw = barrier.get(TASK_NUM).yaw
      barrier.put(TASK_NUM,1)
      }


      #POS_DES = math.vec2.add(target,pose.position)
    }



    if (TIME_STEP > 1) {
    if(pushers.in()){
    if(TASK)
    {
    #show_colored_trajectory()
    log(id,": ", Pushed_obj_pos.x,Pushed_obj_pos.y)
    log(id,": distance_to_target",math.vec2.dis(POS_DES,Pushed_obj_pos))
    var move_vec = obtain_local_vec_to_target(POS_DES,pose.position,pose.orientation.yaw) 
    #log("id",move_vec.x,move_vec.y)
    vector_to_target = math.vec2.scale(math.vec2.norm(move_vec), 35)
    move_in=obtain_local_vec_to_target(Pushed_obj_pos,pose.position,pose.orientation.yaw)
    move_in = math.vec2.scale(math.vec2.norm(move_in), 25)
    vector_to_neighbour = find_neighbours()
    if (math.vec2.dis(vector_to_neighbour,Pushed_obj_pos)>0){
    vector_to_neighbour = math.vec2.scale(math.vec2.norm(vector_to_neighbour), +40)}
    vector_to_target = math.vec2.add(vector_to_neighbour,vector_to_target)
    vector_to_target = math.vec2.add(vector_to_target,move_in)
    vector_to_target = math.vec2.scale(math.vec2.norm(vector_to_target), 10)
    goto(vector_to_target.x, vector_to_target.y)
    if(math.vec2.dis(POS_DES,pose.position)<0.05)
    {
      TASK = 0
      #pushers.leave()
      set_wheels(0.0,0.0)
      log(id,":",barrier.get(TASK_NUM))
      cnt = barrier.get(TASK_NUM)
      barrier.put(TASK_NUM,cnt + 1)
      

    }

    }}	
     

     
    if(rotaters.in())
    {
      
      if (TASK)
      {
      #log(id,"pose",pose.position.x,":",pose.position.y,":",pose.orientation.yaw)
      #show_colored_trajectory()
      move_per=obtain_perpendicular(Pushed_obj_pos,pose.position)
      move_in=obtain_local_vec_to_target(Pushed_obj_pos,pose.position,pose.orientation.yaw)
      move_per = math.vec2.scale(math.vec2.norm(move_per), 30)
      move_in = math.vec2.scale(math.vec2.norm(move_in), 15)
      move_away = find_neighbours()
      if (math.vec2.dis(move_away,Pushed_obj_pos)>0){
      #log(id)
      move_away = math.vec2.scale(math.vec2.norm(move_away), +20)}
      vector_to_target = math.vec2.add(move_per,move_in) 
      #log(id, "vec",vector_to_target.x,":",vector_to_target.x)
      vector_to_target = math.vec2.add(vector_to_target,move_away)
      vector_to_target = math.vec2.scale(math.vec2.norm(vector_to_target), 3)
      #log(id, "vec_tot",vector_to_target.x,":",vector_to_target.y)
      goto(vector_to_target.x,vector_to_target.y)
      present_vec = math.vec2.sub(pose.position,Pushed_obj_pos)
      present_dis = math.vec2.dis(pose.position,Pushed_obj_pos)
      num = math.vec2.dot(present_vec,init_vector)
      denom = present_dis * init_distance
      angle = math.acos(num/denom)
      #log(id,":",angle)
      if ((angle > (yaw - 0.02)) and (angle < (yaw + 0.02)))
      {
       TASK = 0
       set_wheels(0.0,0.0)
       #rotaters.leave()
       log(id,":",barrier.get(TASK_NUM))
       cnt = barrier.get(TASK_NUM)
       barrier.put(TASK_NUM,cnt + 1)
      }
      }
    }
    
  
    }
    TIME_STEP = TIME_STEP + 1
}

function obtain_local_vec_to_target(coord1,coord2,yaw)
{
    m_target = math.vec2.new(coord1.x,coord1.y)
    m_pos = math.vec2.new(coord2.x,coord2.y)
    m_target = math.vec2.sub(m_target,m_pos)
    m_target = math.vec2.rotate(m_target,-yaw)
    return m_target
}


function obtain_perpendicular(coord1,coord2)
{
    m_pos = math.vec2.new(coord2.x,coord2.y)
    m_object = math.vec2.new(coord1.x,coord1.y)
    m_target = math.vec2.sub(m_object,m_pos)
    m_target = math.vec2.rotate(m_target,1.57 - pose.orientation.yaw)

    return m_target

}



function find_neighbours()
{
             Accum ={.x=0,.y=0, .error=0 }
             neighbors.foreach(
                function(rid, data) {
                    var error = ((data.distance - 25)/data.distance)
                    var angular_error = 0
                    if(n[rid]) angular_error=(data.azimuth - n[rid].a)/3.14 * 180
                    
                    Accum.error = Accum.error + math.abs(error)
                    if((n[rid]) or (data.distance < 30)){
                        var my_vec = math.vec2.newp(data.distance, data.azimuth)
                        Accum.x= Accum.x + ( error * (my_vec.x - math.cos(angular_error)))
                        Accum.y= Accum.y + ( error * (my_vec.y - math.sin(angular_error)))
                        # log("[",id,"] -> ",rid," Accum : (", Accum.x,",",Accum.y,") Error", error,"Ang error ",angular_error," Ang Target ", Rigid_nei[nei_in_set].value.azimuth ," Cur", data.azimuth ," dist ", data.distance)
                    }
                }
            )
            return Accum

}

function find_nei_in_set()
{
  var neighbours = {}
  neighbors.foreach(
  function(rid, data) 
  {
    if (data.distance<0)
      {
        log(id," : ",rid," : ",data.distance," : ",data.azimuth)
        neighbours[rid] = {.a = data.azimuth}
      }
  })
  return neighbours
}

function table_print_path(t) {
  var t2 = {}
  foreach(t, function(key, value) {
      var ltab = {.x=value.x,.y=value.y}
      log(id,":",key," : ",ltab.x," : ",ltab.y)
    })
  
}
