include "includes/vec2.bzz"
include "includes/RVO.bzz"
include "includes/debug.bzz"


Pushed_obj_pos = {}
target = {.x=2.0,.y=2.0}


function init() {
TASK = 1
pushers=swarm.create(4)
pushers.join()
TIME_STEP = 1
POS_DES = {.x=0,.y=0}
}

function step()
{

    debug.print(" ")

    if (TIME_STEP == 1)
        {
            n = find_nei_in_set()
            POS_DES = math.vec2.add(target,pose.position)
        }
    else 
        {
           if(pushers.in())
                 {
                     if(TASK)
                          {
                              show_colored_trajectory()
                              #log(id,": distance_to_target",math.vec2.dis(target,Pushed_obj_pos))
                              var move_vec = obtain_local_vec_to_target(POS_DES,pose.position,pose.orientation.yaw) 
                              #log("id",move_vec.x,move_vec.y)
                              vector_to_target = math.vec2.scale(math.vec2.norm(move_vec), 20)
                              move_in=obtain_local_vec_to_target(Pushed_obj_pos,pose.position,pose.orientation.yaw)
                              move_in = math.vec2.scale(math.vec2.norm(move_in), 10)
                              vector_to_neighbour = find_neighbours()
                                 if (math.vec2.dis(vector_to_neighbour,{.x=0,.y=0})>0){
                                      vector_to_neighbour = math.vec2.scale(math.vec2.norm(vector_to_neighbour), +20)}
                              vector_to_target = math.vec2.add(vector_to_neighbour,vector_to_target)
                              vector_to_target = math.vec2.add(vector_to_target,move_in)
                              vector_to_target = math.vec2.scale(math.vec2.norm(vector_to_target), +10)
                              goto(vector_to_target.x, vector_to_target.y)
                                  if(math.vec2.dis(POS_DES,pose.position)<0.01)
                                      {
                                      TASK = 0
                                      pushers.leave()
                                      set_wheels(0.0,0.0)
                                      log(id,"pushed")
                                      }

                           }
                  }	
  
        }
    TIME_STEP = TIME_STEP + 1
}

function obtain_local_vec_to_target(coord1,coord2,yaw)
{
    m_target = math.vec2.new(coord1.x,coord1.y)
    m_pos = math.vec2.new(coord2.x,coord2.y)
    m_target = math.vec2.sub(m_target,m_pos)
    m_target = math.vec2.rotate(m_target,-yaw)
    return m_target
}


function find_neighbours()
{
             Accum ={.x=0,.y=0, .error=0 }
             neighbors.foreach(
                function(rid, data) {
                    var error = ((data.distance - 25)/data.distance)
                    var angular_error = 0
                    if(n[rid]) angular_error=(data.azimuth - n[rid].a)/3.14 * 180
                    
                    Accum.error = Accum.error + math.abs(error)
                    if((n[rid]) or (data.distance < 30)){
                        var my_vec = math.vec2.newp(data.distance, data.azimuth)
                        Accum.x= Accum.x + ( error * (my_vec.x - math.cos(angular_error)))
                        Accum.y= Accum.y + ( error * (my_vec.y - math.sin(angular_error)))
                        # log("[",id,"] -> ",rid," Accum : (", Accum.x,",",Accum.y,") Error", error,"Ang error ",angular_error," Ang Target ", Rigid_nei[nei_in_set].value.azimuth ," Cur", data.azimuth ," dist ", data.distance)
                    }
                }
            )
            return Accum

}

function find_nei_in_set()
{
  var neighbours = {}
  neighbors.foreach(
  function(rid, data) 
  {
    if (data.distance<30)
      {
        log(id," : ",rid," : ",data.distance," : ",data.azimuth)
        neighbours[rid] = {.a = data.azimuth}
      }
  })
  return neighbours
}

